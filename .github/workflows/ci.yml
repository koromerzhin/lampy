name: CI Pipeline

on: 
  push:
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOCKER_INTERACTIVE: false
  NODE_VERSION: 22
  COMPOSE_DOCKER_CLI_BUILD: 1
  DOCKER_BUILDKIT: 1
  STACK_NAME: lampy
  DOCKER_COMPOSE_VERSION: '2.29.7'
  # Optimisations npm
  NPM_CONFIG_PROGRESS: false
  NPM_CONFIG_AUDIT: false
  # Optimisations Docker
  DOCKER_CLI_EXPERIMENTAL: enabled

permissions:
  contents: read
  packages: read

jobs:
  ci:
    name: CI Tests
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Setup Task
        uses: go-task/setup-task@v1

      - name: Setup Docker Compose
        uses: KengoTODA/actions-setup-docker-compose@v1
        with:
          version: ${{ env.DOCKER_COMPOSE_VERSION }}

      - name: Setup Docker cache
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Install and validate dependencies
        run: |
          echo "ğŸ“¦ Installation et validation des dÃ©pendances..."
          npm ci --prefer-offline
          npm run lint:markdown
          echo "âœ… DÃ©pendances installÃ©es et validÃ©es"

      - name: Initialize Docker environment
        run: |
          echo "ğŸ³ Initialisation de l'environnement Docker..."
          task lampy:swarm-init
          task lampy:create-network
          echo "âœ… Environnement Docker initialisÃ©"

      - name: Prepare and deploy stack
        run: |
          echo "â¬‡ï¸ PrÃ©paration et dÃ©ploiement..."
          task lampy:getpull-image
          task lampy:deploy
          echo "âœ… Stack dÃ©ployÃ©e"

      - name: Wait and verify services
        timeout-minutes: 5
        run: |
          echo "â³ Attente et vÃ©rification des services..."
          task lampy:waiting
          
          echo "ğŸ” VÃ©rification de la santÃ© des services..."
          # Attendre que les services soient en Ã©tat 'Running'
          for i in {1..30}; do
            running_services=$(docker service ls --filter name=${{ env.STACK_NAME }} --format "{{.Replicas}}" | grep -c "1/1" || echo "0")
            total_services=$(docker service ls --filter name=${{ env.STACK_NAME }} --quiet | wc -l)
            echo "Services en cours: $running_services/$total_services"
            
            if [ "$running_services" -eq "$total_services" ] && [ "$total_services" -gt "0" ]; then
              echo "âœ… Tous les services sont opÃ©rationnels"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "âŒ Timeout: Certains services ne sont pas dÃ©marrÃ©s"
              docker service ls
              docker stack ps ${{ env.STACK_NAME }} --no-trunc
              exit 1
            fi
            
            sleep 10
          done
          
          echo "ğŸ“Š Ã‰tat final des services:"
          docker service ls --filter name=${{ env.STACK_NAME }}
          docker stack ps ${{ env.STACK_NAME }} --format "table {{.Name}}\t{{.Image}}\t{{.CurrentState}}\t{{.Error}}"

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "ğŸ§¹ Nettoyage des ressources Docker aprÃ¨s Ã©chec..."
          echo "ğŸ“Š Diagnostic des services dÃ©faillants:"
          docker service ls --filter name=${{ env.STACK_NAME }} || true
          docker stack ps ${{ env.STACK_NAME }} --no-trunc || true
          
          echo "ï¿½ Logs des services (50 derniÃ¨res lignes):"
          for service in $(docker service ls --filter name=${{ env.STACK_NAME }} --format "{{.Name}}" 2>/dev/null || echo ""); do
            echo "--- Logs pour $service ---"
            docker service logs --tail 50 "$service" 2>/dev/null || echo "Impossible de rÃ©cupÃ©rer les logs pour $service"
          done
          
          echo "ğŸ—‘ï¸ Suppression de la stack..."
          docker stack rm ${{ env.STACK_NAME }} || true
          
          echo "â³ Attente de la suppression complÃ¨te..."
          timeout 60s bash -c 'while docker service ls --filter name=${{ env.STACK_NAME }} --quiet | grep -q .; do sleep 2; done' || true
          
          echo "ğŸ§¹ Nettoyage final du systÃ¨me..."
          docker system prune -f --volumes || true
          echo "âœ… Nettoyage terminÃ©"

      - name: Final cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Nettoyage final automatique..."
          docker stack rm ${{ env.STACK_NAME }} 2>/dev/null || true
          timeout 30s bash -c 'while docker service ls --filter name=${{ env.STACK_NAME }} --quiet | grep -q .; do sleep 2; done' || true
          docker system prune -f 2>/dev/null || true
          echo "âœ… Nettoyage final terminÃ©"